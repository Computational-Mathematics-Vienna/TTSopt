%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% wNOMAD.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% function output = wNOMAD(prob, func, options)
%
% wrapper for the NOMAD solver
%
%
% ARGUMENTS
% ---------
% prob (int/str): tune case if nargin==1 / problem name if nargin>1
%
% func (function handle): handle to the objective function
%
% options (structure):
%
%   .x (column vector): starting point
%
%   .bounds (structure):
%
%     .type (string): string of length n
%       type(i) = "c" if variable i is continuous
%       type(i) = "i" if variable i is integer
%       type(i) = "k" if variable i is categorical
%
%     .low (column vector): lower bounds on x
%
%     .upp (column vector): upper bounds on x
%
%     .cat (value cell array): i-th component is either "" when
%       variable i is not categorical, or a cell array of non-empty
%       strings defining all possible states of variable i, e.g.
%       { {"blue", "black"}, "", {"blue", "green", "yellow"} }
%
%   .prt (int): printlevel
%     0: nothing,
%     1: little,
%     >1: more and more
%     there are no other options on this level,
%     as the solver id specifies solver-dependent options
%
%   .resfile (str): result file (path relative to RESpath)
%
%   .accf (float): desired maximum norm of gradient
%
%   .nfmax (int): bounds on number of function values
%
%   .secmax (int): bounds on number of seconds
%
%   .redgrad (bool): return reduced gradient or not
%     0 is default for BBO problems
%
%   .TuneCase (int): tuning case for solver
%     -1: uses options.solverParams
%     0: no tuning, uses default parameters of solver
%     >1: predefined tuning parameters
%
%   .solverParams (structure): solver paramaters to pass through
%     in the user tuning case
%
%     .BB_OUTPUT_TYPE (str): "OBJ"
%       Blackbox output types
%       available options are: "OBJ": objective value to minimize
%       (define twice for bi-objective) "PB": constraint <= 0 treated
%       with Progressive Barrier (PB) "CSTR": same as "PB"  "EB":
%       constraint <= 0 treated with Extreme Barrier (EB) "F":
%       constraint <= 0 treated with Filter "CNT_EVAL": 0 or 1 output:
%       count or not the evaluation "NOTHING": this output is ignored
%       "EXTRA_O": same as "NOTHING"
%
%     .LH_SEARCH_1 (int): 100
%       first argument of Latin-Hypercube sampling (search)
%
%     .LH_SEARCH_2 (int): 0
%       second argument of Latin-Hypercube sampling (search)
%
%     .QUAD_MODEL_SEARCH_BOUND_REDUCTION_FACTOR (float): 1.0
%       The quad model is built on evaluation points around a frame
%       center. This  defines min and max bounds, from which we define a
%       model center. The model  search is limited to tighter (can be
%       wider with the parameter set to less than 1)  bounds by reducing
%       the distance of the optimization bounds to the model center.  We
%       use a reduction factor for that. If the reduction factor equals
%       one, the min  and max bounds are used as optimization bounds for
%       the search. The greater the  reduction factor, the tighter the
%       bounds.
%
%     .QUAD_MODEL_SEARCH_BOX_FACTOR (float): 4.0
%       Quadratic model search point selection factor.      This
%       parameter is used to select points to build the quadratic model
%       for  the search method. The max, min and average of trial points
%       coordinates are used to identify a  box. This box contains all
%       trial points to sort.  The box is enlarged by this factor. Cache
%       evaluation points inside this box  are selected to build the
%       quadratic model for search.
%
%     .QUAD_MODEL_SORT_BOX_FACTOR (float): 2.0
%       Quadratic model sort point selection factor.        This
%       parameter is used to select points to build the quadratic model
%       for  sorting trial points  The max, min and average of trial
%       points coordinates are used to identify a  box. This box
%       contains all trial points to sort.  The box is enlarged by this
%       factor. Cache evaluation points inside this box  are selected to
%       build the quadratic model for sort.
%
%     .SGTELIB_MODEL_RADIUS_FACTOR (float): 2.0
%       Sgtelib model radius factor.       This parameter is used to
%       select points to build the sgtelib model  Frame size is
%       multiplied by this factor to get the search radius.    Points
%       inside a circle centered on the poll center, within this radius,
%       are selected to build the sgtelib model
%
%     .SGTELIB_MODEL_SEARCH_TRIALS (int): 1
%       Max number of sgtelib model search failures before going to the
%       poll step.
%
%     .DISPLAY_ALL_EVAL (int): 0
%       available options are: true: more points are displayed with
%       parameters DISPLAY_STATS and  STATS_FILE false: only the
%       successful evaluations are displayed
%
%     .BB_MAX_BLOCK_SIZE (int): 1
%       Maximum size of a block of evaluations send to the blackbox
%       executable at once. Blackbox executable can manage parallel
%       evaluations on its own. Opportunistic strategies may apply after
%       each block of evaluations.  Depending on the algorithm phase,
%       the blackbox executable will  receive at most BB_MAX_BLOCK_SIZE
%       points to evaluate.  When this parameter is greater than one,
%       the number of evaluations  may exceed the MAX_BB_EVAL stopping
%       criterion.
%
%     .QUAD_MODEL_MAX_BLOCK_SIZE (float): inf
%       Maximum size of a block of evaluations send to the quad model
%       evaluator  at once. Opportunistic strategies may apply after
%       each block of evaluations.  Depending on the algorithm phase,
%       the quad model will  receive at most QUAD_MODEL_MAX_BLOCK_SIZE
%       points to evaluate.  When this parameter is greater than one,
%       the number of evaluations  may exceed the QUAD_MODEL_MAX_EVAL
%       stopping criterion.
%
%     .QUAD_MODEL_MAX_EVAL (int): 5000
%       Max number of model evaluations for each optimization of the
%       quad model problem.
%
%     .SGTELIB_MODEL_MAX_BLOCK_SIZE (float): inf
%       Maximum size of a block of evaluations send to the sgtelib model
%       evaluator  at once. Opportunistic strategies may apply after
%       each block of evaluations. Depending on the algorithm phase, the
%       sgtelib will  receive at most SGTELIB_MODEL_MAX_BLOCK_SIZE
%       points to evaluate.  When this parameter is greater than one,
%       the number of evaluations  may exceed the SGTELIB_MODEL_MAX_EVAL
%       stopping criterion.
%
%     .SGTELIB_MODEL_MAX_EVAL (int): 1000
%       Max number of model evaluations for each optimization of the
%       sgtelib model problem.
%
%     .EVAL_OPPORTUNISTIC (int): 1
%       Opportunistic strategy: Terminate evaluations as soon as a
%       success is found. This parameter is the default value for other
%       OPPORTUNISTIC parameters,  including Search steps. This
%       parameter is the value used for Poll step.
%
%     .EVAL_QUEUE_SORT (str): "QUADRATIC_MODEL"
%       available options are: "DIR_LAST_SUCCESS": Points that are
%       generated in a direction similar to the  last direction that
%       provided a successful point are evaluated first.
%       "LEXICOGRAPHICAL": Points are sorted in lexicographical order
%       before evaluation.  "RANDOM": Mix points randomly before
%       evaluation, instead of sorting them.  "SURROGATE": Sort points
%       using values given by static surrogate. See parameter
%       SURROGATE_EXE.  "QUADRATIC_MODEL": Sort points using values
%       given by dynamic quadratic models.
%
%     .EVAL_USE_CACHE (int): 1
%       When this parameter is false, the Cache is not used at all.
%       Points may be  re-evaluated. Recommended when DIMENSION is large
%       and evaluations are not costly.   Cache may be used for top
%       algorithm, and disabled for a sub-algorithm. If CACHE_FILE is
%       non-empty, cache file will still be read and written.
%
%     .FRAME_CENTER_USE_CACHE (int): 0
%       available options are: true: when the Update step occurs, the
%       points with  the best values are found in the Cache. Multiple
%       points may have the same  value. These points are all used as
%       frame centers for the next Search and  Poll steps. false: the
%       frame centers (one feasible and one  infeasible) are kept from
%       previous iterations. This is the classical  MADS algorithm.
%
%     .HOT_RESTART_ON_USER_INTERRUPT (int): 0
%       available options are: true: when NOMAD runs and the user does
%       an interruption (CTRL+C),  then the parameters can be modified.
%       Upon pressing CTRL+D, the resolution  continues where it was
%       stopped, using the modified parameters. false: when NOMAD runs
%       and the user does an interruption (CTRL+C),  the resolution
%       ends.
%
%     .MAX_ITERATION_PER_MEGAITERATION (float): inf
%       Maximum number of Iterations to generate for each MegaIteration.
%       If there are few points in the barrier, this parameter has no
%       effect. If FRAME_CENTER_USE_CACHE is false, this parameter has
%       no effect. If there are many points in the barrier, this
%       parameter limits  the number of iterations generated.  A mixture
%       of feasible and infeasible points of the barrier is used to
%       generate iterations.  Each iteration uses a point of the barrier
%       as frame center.
%
%     .NM_DELTA_E (float): 2.0
%       Nelder Mead expansion parameter
%
%     .NM_DELTA_IC (float): -0.5
%       Nelder Mead inside contraction parameter
%
%     .NM_DELTA_OC (float): 0.5
%       Nelder Mead outside contraction parameter
%
%     .NM_GAMMA (float): 0.5
%       Nelder Mead shrink parameter
%
%     .RANDOM_ALGO_DUMMY_FACTOR (int): 1
%       This is dummy factor used by random algo.           Use this as
%       a template for a parameter controling the behavior of a new
%       search            method.
%
%     .SEED (int): 0
%       Random seed.           Choose -1 for generating a different seed
%       for each run.
%
%
% RETURNS
% -------
% nargin == 0: returns nothing, just prints info about the solver
%
% nargin == 1: prints info about the tuning case
% output (structure): info about specified tuning parameter
%
% nargin > 1:
% output (structure): best point, function value and additional info
%
%   .xbest (column vector): best point found by solver
%
%   .fbest (float): best function value found by solver
%
%   .solname (str): name of solver and tune case
%     for saving data in TESTrun
%
%   .solverInfo (row vector): info from the solver
%
%   .funInfo (structure): additional info


function output = wNOMAD(prob, func, options)

  global SOLpath RESpath WORKpath finfo

  % self tuning without using mixed integer solver
  solverParams = {};
  solverParams{1} = struct('BB_OUTPUT_TYPE','OBJ', 'LH_SEARCH_1',100,...
    'LH_SEARCH_2',0, 'QUAD_MODEL_SEARCH_BOUND_REDUCTION_FACTOR',1.0,...
    'QUAD_MODEL_SEARCH_BOX_FACTOR',4.0,...
    'QUAD_MODEL_SORT_BOX_FACTOR',2.0, 'SGTELIB_MODEL_RADIUS_FACTOR',2.0,...
    'SGTELIB_MODEL_SEARCH_TRIALS',1, 'DISPLAY_ALL_EVAL',0,...
    'BB_MAX_BLOCK_SIZE',1, 'QUAD_MODEL_MAX_BLOCK_SIZE',inf,...
    'QUAD_MODEL_MAX_EVAL',5000, 'SGTELIB_MODEL_MAX_BLOCK_SIZE',inf,...
    'SGTELIB_MODEL_MAX_EVAL',1000, 'EVAL_OPPORTUNISTIC',1,...
    'EVAL_QUEUE_SORT','QUADRATIC_MODEL', 'EVAL_USE_CACHE',1,...
    'FRAME_CENTER_USE_CACHE',0, 'HOT_RESTART_ON_USER_INTERRUPT',0,...
    'MAX_ITERATION_PER_MEGAITERATION',inf, 'NM_DELTA_E',2.0,...
    'NM_DELTA_IC',-0.5, 'NM_DELTA_OC',0.5, 'NM_GAMMA',0.5,...
    'RANDOM_ALGO_DUMMY_FACTOR',1, 'SEED',0);


  % custom exception
  badCase = 'DFO:BadSolverParameterCase';
  badCaseMsg = '%d is not a valid option case. Must be an integer in [-1, 1].';

  switch nargin

    case 0 % no argument -> returns info about solver

      disp(strvcat({...
'function output = wNOMAD(prob, func, options)',...
' ',...
'wrapper for the NOMAD solver',...
' ',...
' ',...
'ARGUMENTS',...
'---------',...
'prob (int/str): tune case if nargin==1 / problem name if nargin>1',...
' ',...
'func (function handle): handle to the objective function',...
' ',...
'options (structure):',...
' ',...
'  .x (column vector): starting point',...
' ',...
'  .bounds (structure):',...
' ',...
'    .type (string): string of length n',...
'      type(i) = "c" if variable i is continuous',...
'      type(i) = "i" if variable i is integer',...
'      type(i) = "k" if variable i is categorical',...
' ',...
'    .low (column vector): lower bounds on x',...
' ',...
'    .upp (column vector): upper bounds on x',...
' ',...
'    .cat (value cell array): i-th component is either "" when',...
'      variable i is not categorical, or a cell array of non-empty',...
'      strings defining all possible states of variable i, e.g.',...
'      { {"blue", "black"}, "", {"blue", "green", "yellow"} }',...
' ',...
'  .prt (int): printlevel',...
'    0: nothing,',...
'    1: little,',...
'    >1: more and more',...
'    there are no other options on this level,',...
'    as the solver id specifies solver-dependent options',...
' ',...
'  .resfile (str): result file (path relative to RESpath)',...
' ',...
'  .accf (float): desired maximum norm of gradient',...
' ',...
'  .nfmax (int): bounds on number of function values',...
' ',...
'  .secmax (int): bounds on number of seconds',...
' ',...
'  .redgrad (bool): return reduced gradient or not',...
'    0 is default for BBO problems',...
' ',...
'  .TuneCase (int): tuning case for solver',...
'    -1: uses options.solverParams',...
'    0: no tuning, uses default parameters of solver',...
'    >1: predefined tuning parameters',...
' ',...
'  .solverParams (structure): solver paramaters to pass through',...
'    in the user tuning case',...
' ',...
'    .BB_OUTPUT_TYPE (str): "OBJ"',...
'      Blackbox output types',...
'      available options are: "OBJ": objective value to minimize (define',...
'      twice for bi-objective) "PB": constraint <= 0 treated with',...
'      Progressive Barrier (PB) "CSTR": same as "PB"  "EB": constraint',...
'      <= 0 treated with Extreme Barrier (EB) "F": constraint <= 0',...
'      treated with Filter "CNT_EVAL": 0 or 1 output: count or not the',...
'      evaluation "NOTHING": this output is ignored "EXTRA_O": same as',...
'      "NOTHING"',...
' ',...
'    .LH_SEARCH_1 (int): 100',...
'      first argument of Latin-Hypercube sampling (search)',...
' ',...
'    .LH_SEARCH_2 (int): 0',...
'      second argument of Latin-Hypercube sampling (search)',...
' ',...
'    .QUAD_MODEL_SEARCH_BOUND_REDUCTION_FACTOR (float): 1.0',...
'      The quad model is built on evaluation points around a frame',...
'      center. This  defines min and max bounds, from which we define a',...
'      model center. The model  search is limited to tighter (can be',...
'      wider with the parameter set to less than 1)  bounds by reducing',...
'      the distance of the optimization bounds to the model center.  We',...
'      use a reduction factor for that. If the reduction factor equals',...
'      one, the min  and max bounds are used as optimization bounds for',...
'      the search. The greater the  reduction factor, the tighter the',...
'      bounds.',...
' ',...
'    .QUAD_MODEL_SEARCH_BOX_FACTOR (float): 4.0',...
'      Quadratic model search point selection factor.      This',...
'      parameter is used to select points to build the quadratic model',...
'      for  the search method. The max, min and average of trial points',...
'      coordinates are used to identify a  box. This box contains all',...
'      trial points to sort.  The box is enlarged by this factor. Cache',...
'      evaluation points inside this box  are selected to build the',...
'      quadratic model for search.',...
' ',...
'    .QUAD_MODEL_SORT_BOX_FACTOR (float): 2.0',...
'      Quadratic model sort point selection factor.        This',...
'      parameter is used to select points to build the quadratic model',...
'      for  sorting trial points  The max, min and average of trial',...
'      points coordinates are used to identify a  box. This box contains',...
'      all trial points to sort.  The box is enlarged by this factor.',...
'      Cache evaluation points inside this box  are selected to build',...
'      the quadratic model for sort.',...
' ',...
'    .SGTELIB_MODEL_RADIUS_FACTOR (float): 2.0',...
'      Sgtelib model radius factor.       This parameter is used to',...
'      select points to build the sgtelib model  Frame size is',...
'      multiplied by this factor to get the search radius.    Points',...
'      inside a circle centered on the poll center, within this radius,',...
'      are selected to build the sgtelib model',...
' ',...
'    .SGTELIB_MODEL_SEARCH_TRIALS (int): 1',...
'      Max number of sgtelib model search failures before going to the',...
'      poll step.',...
' ',...
'    .DISPLAY_ALL_EVAL (int): 0',...
'      available options are: true: more points are displayed with',...
'      parameters DISPLAY_STATS and  STATS_FILE false: only the',...
'      successful evaluations are displayed',...
' ',...
'    .BB_MAX_BLOCK_SIZE (int): 1',...
'      Maximum size of a block of evaluations send to the blackbox',...
'      executable at once. Blackbox executable can manage parallel',...
'      evaluations on its own. Opportunistic strategies may apply after',...
'      each block of evaluations.  Depending on the algorithm phase, the',...
'      blackbox executable will  receive at most BB_MAX_BLOCK_SIZE',...
'      points to evaluate.  When this parameter is greater than one, the',...
'      number of evaluations  may exceed the MAX_BB_EVAL stopping',...
'      criterion.',...
' ',...
'    .QUAD_MODEL_MAX_BLOCK_SIZE (float): inf',...
'      Maximum size of a block of evaluations send to the quad model',...
'      evaluator  at once. Opportunistic strategies may apply after each',...
'      block of evaluations.  Depending on the algorithm phase, the quad',...
'      model will  receive at most QUAD_MODEL_MAX_BLOCK_SIZE points to',...
'      evaluate.  When this parameter is greater than one, the number of',...
'      evaluations  may exceed the QUAD_MODEL_MAX_EVAL stopping',...
'      criterion.',...
' ',...
'    .QUAD_MODEL_MAX_EVAL (int): 5000',...
'      Max number of model evaluations for each optimization of the quad',...
'      model problem.',...
' ',...
'    .SGTELIB_MODEL_MAX_BLOCK_SIZE (float): inf',...
'      Maximum size of a block of evaluations send to the sgtelib model',...
'      evaluator  at once. Opportunistic strategies may apply after each',...
'      block of evaluations. Depending on the algorithm phase, the',...
'      sgtelib will  receive at most SGTELIB_MODEL_MAX_BLOCK_SIZE points',...
'      to evaluate.  When this parameter is greater than one, the number',...
'      of evaluations  may exceed the SGTELIB_MODEL_MAX_EVAL stopping',...
'      criterion.',...
' ',...
'    .SGTELIB_MODEL_MAX_EVAL (int): 1000',...
'      Max number of model evaluations for each optimization of the',...
'      sgtelib model problem.',...
' ',...
'    .EVAL_OPPORTUNISTIC (int): 1',...
'      Opportunistic strategy: Terminate evaluations as soon as a',...
'      success is found. This parameter is the default value for other',...
'      OPPORTUNISTIC parameters,  including Search steps. This parameter',...
'      is the value used for Poll step.',...
' ',...
'    .EVAL_QUEUE_SORT (str): "QUADRATIC_MODEL"',...
'      available options are: "DIR_LAST_SUCCESS": Points that are',...
'      generated in a direction similar to the  last direction that',...
'      provided a successful point are evaluated first.',...
'      "LEXICOGRAPHICAL": Points are sorted in lexicographical order',...
'      before evaluation.  "RANDOM": Mix points randomly before',...
'      evaluation, instead of sorting them.  "SURROGATE": Sort points',...
'      using values given by static surrogate. See parameter',...
'      SURROGATE_EXE.  "QUADRATIC_MODEL": Sort points using values given',...
'      by dynamic quadratic models.',...
' ',...
'    .EVAL_USE_CACHE (int): 1',...
'      When this parameter is false, the Cache is not used at all.',...
'      Points may be  re-evaluated. Recommended when DIMENSION is large',...
'      and evaluations are not costly.   Cache may be used for top',...
'      algorithm, and disabled for a sub-algorithm. If CACHE_FILE is',...
'      non-empty, cache file will still be read and written.',...
' ',...
'    .FRAME_CENTER_USE_CACHE (int): 0',...
'      available options are: true: when the Update step occurs, the',...
'      points with  the best values are found in the Cache. Multiple',...
'      points may have the same  value. These points are all used as',...
'      frame centers for the next Search and  Poll steps. false: the',...
'      frame centers (one feasible and one  infeasible) are kept from',...
'      previous iterations. This is the classical  MADS algorithm.',...
' ',...
'    .HOT_RESTART_ON_USER_INTERRUPT (int): 0',...
'      available options are: true: when NOMAD runs and the user does an',...
'      interruption (CTRL+C),  then the parameters can be modified. Upon',...
'      pressing CTRL+D, the resolution  continues where it was stopped,',...
'      using the modified parameters. false: when NOMAD runs and the',...
'      user does an interruption (CTRL+C),  the resolution ends.',...
' ',...
'    .MAX_ITERATION_PER_MEGAITERATION (float): inf',...
'      Maximum number of Iterations to generate for each MegaIteration.',...
'      If there are few points in the barrier, this parameter has no',...
'      effect. If FRAME_CENTER_USE_CACHE is false, this parameter has no',...
'      effect. If there are many points in the barrier, this parameter',...
'      limits  the number of iterations generated.  A mixture of',...
'      feasible and infeasible points of the barrier is used to',...
'      generate iterations.  Each iteration uses a point of the barrier',...
'      as frame center.',...
' ',...
'    .NM_DELTA_E (float): 2.0',...
'      Nelder Mead expansion parameter',...
' ',...
'    .NM_DELTA_IC (float): -0.5',...
'      Nelder Mead inside contraction parameter',...
' ',...
'    .NM_DELTA_OC (float): 0.5',...
'      Nelder Mead outside contraction parameter',...
' ',...
'    .NM_GAMMA (float): 0.5',...
'      Nelder Mead shrink parameter',...
' ',...
'    .RANDOM_ALGO_DUMMY_FACTOR (int): 1',...
'      This is dummy factor used by random algo.           Use this as a',...
'      template for a parameter controling the behavior of a new search',...
'      method.',...
' ',...
'    .SEED (int): 0',...
'      Random seed.           Choose -1 for generating a different seed',...
'      for each run.',...
' ',...
' ',...
'RETURNS',...
'-------',...
'nargin == 0: returns nothing, just prints info about the solver',...
' ',...
'nargin == 1: prints info about the tuning case',...
'output (structure): info about specified tuning parameter',...
' ',...
'nargin > 1:',...
'output (structure): best point, function value and additional info',...
' ',...
'  .xbest (column vector): best point found by solver',...
' ',...
'  .fbest (float): best function value found by solver',...
' ',...
'  .solname (str): name of solver and tune case',...
'    for saving data in TESTrun',...
' ',...
'  .solverInfo (row vector): info from the solver',...
' ',...
'  .funInfo (structure): additional info'...
      }));

    case 1 % 1 argument -> returns options of solver
      TuneCase = prob;
      if TuneCase == -1
        disp(['Tuning by mixed integer solver,',...
              ' uses options.solverParams'])
      elseif TuneCase == 0
        disp('No tuning, uses default solver parameters')
      else
        try
          output = solverParams{TuneCase};
          disp('No tuning, uses predefined parameters')
        catch
          error([badCase,' ', badCaseMsg,' ', num2str(TuneCase)]);
        end
      end

    otherwise % all arguments -> calls the solver and returns its output

      bounds = options.bounds;
      TuneCase = options.TuneCase;

      if TuneCase > 0, solname = ['NOMAD',num2str(TuneCase)];
      else, solname = 'NOMAD';
      end

      % diary
      dline = ['===============================================',...
               '=============\n'];
      text = [dline,prob,' ',solname,' ',mytime,'\n'];
      % print on screen
      if options.prt >= 1
        fprintf(1, text);
      end
      % print on resfile
      % result file
      if isfield(options, 'resfile')
        resfile = [RESpath,'/',options.resfile];
      else
        resfile = [RESpath,'/results.res'];
      end

      fid = fopen(resfile, 'a'); % append to current file
      if fid < 0
        error('file not accessible = permissions?');
      end
      fprintf(fid, text);

      if ~isfield(finfo, 'error'), finfo.error = ' '; end

      % if no tune case is provided, uses default solver parameters
      if ~isfield(options, 'TuneCase'), TuneCase = 0; end

      if TuneCase == -1 % tuning with a mixed integer solver
        if ~isfield(options,'solverParams')
          error('DFO:EmptySolverParams',...
                'Tuning is on but options.solverParams is empty.')
        else
          params = options.solverParams;
        end
      elseif TuneCase == 0 % no tuning, uses default solver parameters
        params = [];
      else % no tuning, uses predefined parameters
        try params = solverParams{TuneCase};
        catch
          error([badCase,' ', badCaseMsg,' ', num2str(TuneCase)]);
        end
      end

      % adds paths
      eval(['addpath ',SOLpath,'/nomad']);
     
      options.RESdiary = resfile;
      initf(solname,prob,func,bounds.low,bounds.upp,options);

      % prepare parameters
      x = options.x;
      lb = bounds.low;
      ub = bounds.upp;
      
      params.display_degree = 0;
      params.epsilon = 0;
      
      % rename input types
      type = bounds.type;
      type = strrep(type, 'c', 'R');
      type = strrep(type, 'i', 'I');
      type = strrep(type, 'k', 'C');
      params.bb_input_type = type;
      
      % unpack params structure into keyword-value pairs
      fn = fieldnames(params);
      paramCell = {};
      for i = 1:length(fn)
          paramCell = {paramCell{:}, fn{i}, params.(fn{i})};
      end
      
      if isOctave
        xStr = '';
        lbStr = '';
        ubStr = '';
        first = 1;
        for k = 1:length(x)
          if first
            xStr=[xStr,num2str(x(k))];
            lbStr=[lbStr,num2str(lb(k))];
            ubStr=[ubStr,num2str(ub(k))];
            first = 0;  
          else
            xStr=[xStr,',',num2str(x(k))];
            lbStr=[lbStr,',',num2str(lb(k))];
            ubStr=[ubStr,',',num2str(ub(k))];
          end
        end
      
        paramStr = ''[';
        first = 1;
        for i = 1:length(fn)
          if isnumeric(params.(fn{i}))
              params.(fn{i}) = num2str(params.(fn{i}))
          end
          if iscell(params.(fn{i}))
             params.(fn{i}) = strjoin(params.(fn{i}), '');
          end
          if first == 1
            paramStr = [paramStr,'"',fn{i},' ',params.(fn{i}),'"'];
            first = 0;
          else
            paramStr = [',',paramStr,'"',fn{i},' ',params.(fn{i}),'"'];
          end
        end
        paramStr = [paramStr,']''];
        paramStr
        next
            
      else
        opts = nomadset(paramCell{:});
      end
      
      finfo.unSol2bcProb = 0;

      % call solver
      try
        [x, fval, ~, ~, ~] = nomad(@funf, x, lb, ub, opts);
        
        output.solverInfo.xbest = x;
        output.solverInfo.fbest = fval;

      catch ME
        %%%%%%%%%%%%%%%%%%%%%%%%%
        % enforce stopping test %
        %%%%%%%%%%%%%%%%%%%%%%%%%
        if ~isempty(finfo.error)
          if ~isempty(strfind(finfo.error, 'not allowed'))
            % pass on error
            error(finfo.error);
          end  
          % if a solver fails
          % (which often happens because of a designed error in fun)
          if isempty(strfind(finfo.error,'reached'))
            finfo.error = ME.message;
            if options.prt >= 1
              disp(' ');
              disp(['******************************************',...
                    '*****************']);
              disp(['******************************************',...
                    '*****************']);
              disp(['******************************************',...
                    '*****************']);
              disp(['*** error: ',ME.message]);
              stack = ME.stack;
              for i = 1:length(stack)
                file = stack(i).file;
                name = stack(i).name;
                line = stack(i).line;
                disp(['*** line ',num2str(line),' in    ',name,...
                    '    from ',file]);
              end
              disp(['******************************************',...
                    '*****************']);
              disp(['******************************************',...
                    '*****************']);
              disp(['******************************************',...
                    '*****************']);
              disp(' ');
            end
          end
          if options.prt >= 1
            disp(['stopped since ',finfo.error]);
          end
        end
      end
      if isfield(finfo,'xbest')
        x = finfo.xbest;     % point with best acc
        f = finfo.fbest;     % function value at best acc
      else
        x = finfo.x;         % point with best acc
        f = finfo.f;         % function value at best acc
      end
      acc = finfo.qbest;     % best acc
      nf  = finfo.nf;        % nf of best acc
      maxInfeas = finfo.maxInfeas;
      if acc <= options.accf, status = 0;
      elseif nf >= options.nfmax, status = 1;
      else, status = 2;
      end
      % solution status
      % copy statistics for saving
      funInfo = rmfield(finfo,{'solver','prob','func','low','upp'});
      funInfo.normxfbest = norm(finfo.xbest,inf); % solution norm
      funInfo.status = status;
      % prepares output
      output.xbest       = x;
      output.fbest       = f;
      output.solname     = solname; % for saving data in TESTrun
      output.funInfo     = funInfo;
      % diary
      % number of free variables at solution
      Ic = options.Ic; Ii = options.Ii;
      if length(Ic)>0 && length(Ii)>0
        nfree = sum(x(Ic) > bounds.clow & x(Ic) < bounds.cupp);
        nfree = nfree+sum(x(Ii) > bounds.ilow & x(Ii) < bounds.iupp);
      else
         nfree = sum(x > bounds.low & x < bounds.upp);  
      end
      text = [prob,' ',num2str(nf),': '];
      text1 = [text,sprintf('f=%22.16e\n',f)];
      text2 = ['nf=',num2str(nf),', nfr=',num2str(nfree),...
               sprintf(', status=%i, acc=%7.1e',status,acc')];
      if maxInfeas > 0
        text3 = ['\n   maximal infeasibility of evaluation points: ',...
                 num2str(maxInfeas)];
        text = [text1,text2,text3];
      else
        text = [text1,text2];
      end
      if acc <= options.accf
        text = [text,'\n accuracy achieved'];
      elseif finfo.fbest <= -1e+12
        text = [text,'\n function is unbounded below'];
      else
        text = [text,'\n accuracy too low'];
      end
      showtime0 = showtime;
      text = [text,'\n',showtime0,'\n',solname,' completed - ',mytime];
      text = [dline,text,'\n',dline,'\n\n\n'];
      % print on screen
      if TuneCase == -1
        q.cost = acc;
        if options.prt >= 1
          disp("========================================")
          disp(["cost = ",num2str(q.cost)])
          disp("========================================")
        end
      else
        if options.prt >= 1
          fprintf(1,text);
        end
      end
      % print on resfile
      fprintf(fid,text);
      fclose(fid);
  end % of nargin switch
end % of wNOMAD


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
