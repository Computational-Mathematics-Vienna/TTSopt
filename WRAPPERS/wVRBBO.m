%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% wVRBBO.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% function output = wVRBBO(prob, func, options)
%
% wrapper for the VRBBO solver
%
%
% ARGUMENTS
% ---------
% prob (int/str): tune case if nargin==1 / problem name if nargin>1
%
% func (function handle): handle to the objective function
%
% options (structure):
%
%   .x (column vector): starting point
%
%   .bounds (structure):
%
%     .type (string): string of length n
%       type(i) = "c" if variable i is continuous
%       type(i) = "i" if variable i is integer
%       type(i) = "k" if variable i is categorical
%
%     .low (column vector): lower bounds on x
%
%     .upp (column vector): upper bounds on x
%
%     .cat (value cell array): i-th component is either "" when
%       variable i is not categorical, or a cell array of non-empty
%       strings defining all possible states of variable i, e.g.
%       { {"blue", "black"}, "", {"blue", "green", "yellow"} }
%
%   .prt (int): printlevel
%     0: nothing,
%     1: little,
%     >1: more and more
%     there are no other options on this level,
%     as the solver id specifies solver-dependent options
%
%   .resfile (str): result file (path relative to RESpath)
%
%   .accf (float): desired maximum norm of gradient
%
%   .nfmax (int): bounds on number of function values
%
%   .secmax (int): bounds on number of seconds
%
%   .redgrad (bool): return reduced gradient or not
%     0 is default for BBO problems
%
%   .TuneCase (int): tuning case for solver
%     -1: uses options.solverParams
%     0: no tuning, uses default parameters of solver
%     >1: predefined tuning parameters
%
%   .solverParams (structure): solver paramaters to pass through
%     in the user tuning case
%
%     .msmax (int): 21
%       maximum number of best points kept
%
%     .mqmax (int): 20
%       maximum number of memory for L-BFGS
%
%     .T0 (int): 42
%       maximal number of multi-line searches in setScales
%
%     .alg (int): 5
%       type of algorithm to use
%       1: basic version 2: no random subspace direction 3: no
%       coordinate direction 4: no quasi Newton direction 5: all
%       directions
%
%     .R (int): 20
%       number of random directions
%
%     .C (int): 20
%       maximal number of coordinate trials
%
%     .S (int): 1
%       maximal number of subspace directions in multi-line search
%
%     .E (int): 10
%       maximal number of random trials
%
%     .scSub (float): 0.0
%       scale for subspace direction
%
%     .scCum (float): 0.0
%       scale for cumulative direction
%
%     .scCor (float): 0.0
%       scale for heuristic direction
%
%     .cum (int): 1
%       select cumulative step type
%
%     .a (int): 2
%       upper bound for estimating cumulative step-size
%
%     .Deltamin (float): 1e-10
%       minimium threshold for good impovement
%
%     .Deltamax (float): 0.001
%       initial threshold for good impovement
%
%     .gammadelta (float): 1000000.0
%       factor for finding delta
%
%     .gammamax (float): 0.001
%       factor for adjusting Deltamax
%
%     .gammaE (float): 4.0
%       factor for extrapolation test
%
%     .gammalambda (float): 1e-06
%       factor for finding initial lambda
%
%     .gammaw (float): 1e-10
%       factor for angle condition
%
%     .Q (float): 2.0
%       factor for adjusting delta
%
%     .gammaangle (float): 1e-10
%       factor for angle condition
%
%     .deltamin (float): 0.0001
%       minimum norm of trial step
%
%     .deltamax (float): 0.1
%       maximum norm of trial step
%
%     .alphamin (float): 1e-50
%       minimium threshold for extrapolation step sizes
%
%     .gammamin (float): 1e-06
%       parameter for extrapolation test
%
%
% RETURNS
% -------
% nargin == 0: returns nothing, just prints info about the solver
%
% nargin == 1: prints info about the tuning case
% output (structure): info about specified tuning parameter
%
% nargin > 1:
% output (structure): best point, function value and additional info
%
%   .xbest (column vector): best point found by solver
%
%   .fbest (float): best function value found by solver
%
%   .solname (str): name of solver and tune case
%     for saving data in TESTrun
%
%   .solverInfo (row vector): info from the solver
%
%   .funInfo (structure): additional info


function output = wVRBBO(prob, func, options)

  global SOLpath RESpath WORKpath finfo


  % self tuning without using mixed integer solver
  solverParams = {};
  solverParams{1} = struct('msmax',21, 'mqmax',20, 'T0',42, 'alg',5,...
    'R',20, 'C',20, 'S',1, 'E',10, 'scSub',0.0, 'scCum',0.0,...
    'scCor',0.0, 'cum',1, 'a',2, 'Deltamin',1e-10, 'Deltamax',0.001,...
    'gammadelta',1000000.0, 'gammamax',0.001, 'gammaE',4.0,...
    'gammalambda',1e-06, 'gammaw',1e-10, 'Q',2.0, 'gammaangle',1e-10,...
    'deltamin',0.0001, 'deltamax',0.1, 'alphamin',1e-50,...
    'gammamin',1e-06);


  % custom exception
  badCase = 'DFO:BadSolverParameterCase';
  badCaseMsg = '%d is not a valid option case. Must be an integer in [-1, 1].';

  switch nargin

    case 0 % no argument -> returns info about solver

      disp(strvcat({...
'function output = wVRBBO(prob, func, options)',...
' ',...
'wrapper for the VRBBO solver',...
' ',...
' ',...
'ARGUMENTS',...
'---------',...
'prob (int/str): tune case if nargin==1 / problem name if nargin>1',...
' ',...
'func (function handle): handle to the objective function',...
' ',...
'options (structure):',...
' ',...
'  .x (column vector): starting point',...
' ',...
'  .bounds (structure):',...
' ',...
'    .type (string): string of length n',...
'      type(i) = "c" if variable i is continuous',...
'      type(i) = "i" if variable i is integer',...
'      type(i) = "k" if variable i is categorical',...
' ',...
'    .low (column vector): lower bounds on x',...
' ',...
'    .upp (column vector): upper bounds on x',...
' ',...
'    .cat (value cell array): i-th component is either "" when',...
'      variable i is not categorical, or a cell array of non-empty',...
'      strings defining all possible states of variable i, e.g.',...
'      { {"blue", "black"}, "", {"blue", "green", "yellow"} }',...
' ',...
'  .prt (int): printlevel',...
'    0: nothing,',...
'    1: little,',...
'    >1: more and more',...
'    there are no other options on this level,',...
'    as the solver id specifies solver-dependent options',...
' ',...
'  .resfile (str): result file (path relative to RESpath)',...
' ',...
'  .accf (float): desired maximum norm of gradient',...
' ',...
'  .nfmax (int): bounds on number of function values',...
' ',...
'  .secmax (int): bounds on number of seconds',...
' ',...
'  .redgrad (bool): return reduced gradient or not',...
'    0 is default for BBO problems',...
' ',...
'  .TuneCase (int): tuning case for solver',...
'    -1: uses options.solverParams',...
'    0: no tuning, uses default parameters of solver',...
'    >1: predefined tuning parameters',...
' ',...
'  .solverParams (structure): solver paramaters to pass through',...
'    in the user tuning case',...
' ',...
'    .msmax (int): 21',...
'      maximum number of best points kept',...
' ',...
'    .mqmax (int): 20',...
'      maximum number of memory for L-BFGS',...
' ',...
'    .T0 (int): 42',...
'      maximal number of multi-line searches in setScales',...
' ',...
'    .alg (int): 5',...
'      type of algorithm to use',...
'      1: basic version 2: no random subspace direction 3: no coordinate',...
'      direction 4: no quasi Newton direction 5: all directions',...
' ',...
'    .R (int): 20',...
'      number of random directions',...
' ',...
'    .C (int): 20',...
'      maximal number of coordinate trials',...
' ',...
'    .S (int): 1',...
'      maximal number of subspace directions in multi-line search',...
' ',...
'    .E (int): 10',...
'      maximal number of random trials',...
' ',...
'    .scSub (float): 0.0',...
'      scale for subspace direction',...
' ',...
'    .scCum (float): 0.0',...
'      scale for cumulative direction',...
' ',...
'    .scCor (float): 0.0',...
'      scale for heuristic direction',...
' ',...
'    .cum (int): 1',...
'      select cumulative step type',...
' ',...
'    .a (int): 2',...
'      upper bound for estimating cumulative step-size',...
' ',...
'    .Deltamin (float): 1e-10',...
'      minimium threshold for good impovement',...
' ',...
'    .Deltamax (float): 0.001',...
'      initial threshold for good impovement',...
' ',...
'    .gammadelta (float): 1000000.0',...
'      factor for finding delta',...
' ',...
'    .gammamax (float): 0.001',...
'      factor for adjusting Deltamax',...
' ',...
'    .gammaE (float): 4.0',...
'      factor for extrapolation test',...
' ',...
'    .gammalambda (float): 1e-06',...
'      factor for finding initial lambda',...
' ',...
'    .gammaw (float): 1e-10',...
'      factor for angle condition',...
' ',...
'    .Q (float): 2.0',...
'      factor for adjusting delta',...
' ',...
'    .gammaangle (float): 1e-10',...
'      factor for angle condition',...
' ',...
'    .deltamin (float): 0.0001',...
'      minimum norm of trial step',...
' ',...
'    .deltamax (float): 0.1',...
'      maximum norm of trial step',...
' ',...
'    .alphamin (float): 1e-50',...
'      minimium threshold for extrapolation step sizes',...
' ',...
'    .gammamin (float): 1e-06',...
'      parameter for extrapolation test',...
' ',...
' ',...
'RETURNS',...
'-------',...
'nargin == 0: returns nothing, just prints info about the solver',...
' ',...
'nargin == 1: prints info about the tuning case',...
'output (structure): info about specified tuning parameter',...
' ',...
'nargin > 1:',...
'output (structure): best point, function value and additional info',...
' ',...
'  .xbest (column vector): best point found by solver',...
' ',...
'  .fbest (float): best function value found by solver',...
' ',...
'  .solname (str): name of solver and tune case',...
'    for saving data in TESTrun',...
' ',...
'  .solverInfo (row vector): info from the solver',...
' ',...
'  .funInfo (structure): additional info'...
      }));

    case 1 % 1 argument -> returns options of solver
      TuneCase = prob;
      if TuneCase == -1
        disp(['Tuning by mixed integer solver,',...
              ' uses options.solverParams'])
      elseif TuneCase == 0
        disp('No tuning, uses default solver parameters')
      else
        try
          output = solverParams{TuneCase};
          disp('No tuning, uses predefined parameters')
        catch
          error([badCase,' ', badCaseMsg,' ', num2str(TuneCase)]);
        end
      end

    otherwise % all arguments -> calls the solver and returns its output

      bounds = options.bounds;
      TuneCase = options.TuneCase;

      if TuneCase > 0, solname = ['VRBBO',num2str(TuneCase)];
      else, solname = 'VRBBO';
      end

      % diary
      dline = ['===============================================',...
               '=============\n'];
      text = [dline,prob,' ',solname,' ',mytime,'\n'];
      % print on screen
      if options.prt >= 1
        fprintf(1, text);
      end
      % print on resfile
      % result file
      if isfield(options, 'resfile')
        resfile = [RESpath,'/',options.resfile];
      else
        resfile = [RESpath,'/results.res'];
      end

      fid = fopen(resfile, 'a'); % append to current file
      if fid < 0
        error('file not accessible = permissions?');
      end
      fprintf(fid, text);

      if ~isfield(finfo, 'error'), finfo.error = ' '; end

      % if no tune case is provided, uses default solver parameters
      if ~isfield(options, 'TuneCase'), TuneCase = 0; end

      if TuneCase == -1 % tuning with a mixed integer solver
        if ~isfield(options,'solverParams')
          error('DFO:EmptySolverParams',...
                'Tuning is on but options.solverParams is empty.')
        else
          params = options.solverParams;
        end
      elseif TuneCase == 0 % no tuning, uses default solver parameters
        params = [];
      else % no tuning, uses predefined parameters
        try params = solverParams{TuneCase};
        catch
          error([badCase,' ', badCaseMsg,' ', num2str(TuneCase)]);
        end
      end

      % adds paths
      eval(['addpath ',SOLpath,'/VRBBO']);
     
      options.RESdiary = resfile;

      initf(solname,prob,func,bounds.low,bounds.upp,options);
      
      % prepare parameters
      x = options.x;
      
      st.secmax = inf;
      st.nfmax = 1e8;
      st.fbest = -inf;
      st.accf = -inf;
      st.prt = -1;
      
      finfo.unSol2bcProb = 0;

      % call solver
      try
        [xbest, fbest, ~] = VRBBO(@funf, x, st, params);
 
        output.solverInfo.xbest = xbest;
        output.solverInfo.fbest = fbest;

      catch ME
        %%%%%%%%%%%%%%%%%%%%%%%%%
        % enforce stopping test %
        %%%%%%%%%%%%%%%%%%%%%%%%%
        if ~isempty(finfo.error)
          if ~isempty(strfind(finfo.error, 'not allowed'))
            % pass on error
            error(finfo.error);
          end  
          % if a solver fails
          % (which often happens because of a designed error in fun)
          if isempty(strfind(finfo.error,'reached'))
            finfo.error = ME.message;
            if options.prt >= 1
              disp(' ');
              disp(['******************************************',...
                    '*****************']);
              disp(['******************************************',...
                    '*****************']);
              disp(['******************************************',...
                    '*****************']);
              disp(['*** error: ',ME.message]);
              stack = ME.stack;
              for i = 1:length(stack)
                file = stack(i).file;
                name = stack(i).name;
                line = stack(i).line;
                disp(['*** line ',num2str(line),' in    ',name,...
                    '    from ',file]);
              end
              disp(['******************************************',...
                    '*****************']);
              disp(['******************************************',...
                    '*****************']);
              disp(['******************************************',...
                    '*****************']);
              disp(' ');
            end
          end
          if options.prt >= 1
            disp(['stopped since ',finfo.error]);
          end
        end
      end
      if isfield(finfo,'xbest')
        x = finfo.xbest;     % point with best acc
        f = finfo.fbest;     % function value at best acc
      else
        x = finfo.x;         % point with best acc
        f = finfo.f;         % function value at best acc
      end
      acc = finfo.qbest;     % best acc
      nf  = finfo.nf;        % nf of best acc
      maxInfeas = finfo.maxInfeas;
      if acc <= options.accf, status = 0;
      elseif nf >= options.nfmax, status = 1;
      else, status = 2;
      end
      % solution status
      % copy statistics for saving
      funInfo = rmfield(finfo,{'solver','prob','func','low','upp'});
      funInfo.normxfbest = norm(finfo.xbest,inf); % solution norm
      funInfo.status = status;
      % prepares output
      output.xbest       = x;
      output.fbest       = f;
      output.solname     = solname; % for saving data in TESTrun
      output.funInfo     = funInfo;
      % diary
      % number of free variables at solution
      Ic = options.Ic; Ii = options.Ii;
      if length(Ic)>0 && length(Ii)>0
        nfree = sum(x(Ic) > bounds.clow & x(Ic) < bounds.cupp);
        nfree = nfree+sum(x(Ii) > bounds.ilow & x(Ii) < bounds.iupp);
      else
         nfree = sum(x > bounds.low & x < bounds.upp);  
      end
      text = [prob,' ',num2str(nf),': '];
      text1 = [text,sprintf('f=%22.16e\n',f)];
      text2 = ['nf=',num2str(nf),', nfr=',num2str(nfree),...
               sprintf(', status=%i, acc=%7.1e',status,acc')];
      if maxInfeas > 0
        text3 = ['\n   maximal infeasibility of evaluation points: ',...
                 num2str(maxInfeas)];
        text = [text1,text2,text3];
      else
        text = [text1,text2];
      end
      if acc <= options.accf
        text = [text,'\n accuracy achieved'];
      elseif finfo.fbest <= -1e+12
        text = [text,'\n function is unbounded below'];
      else
        text = [text,'\n accuracy too low'];
      end
      showtime0 = showtime;
      text = [text,'\n',showtime0,'\n',solname,' completed - ',mytime];
      text = [dline,text,'\n',dline,'\n\n\n'];
      % print on screen
      if TuneCase == -1
        q.cost = acc;
        if options.prt >= 1
          disp("========================================")
          disp(["cost = ",num2str(q.cost)])
          disp("========================================")
        end
      else
        if options.prt >= 1
          fprintf(1,text);
        end
      end
      % print on resfile
      fprintf(fid,text);
      fclose(fid);
  end % of nargin switch
end % of wVRBBO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
